var documenterSearchIndex = {"docs":
[{"title":"Reference","page":"Reference","location":"reference/#Reference","category":"section","text":""},{"title":"MemoryViews.DelimitedIterator","page":"Reference","location":"reference/#MemoryViews.DelimitedIterator","category":"type","text":"Iterator struct created by split_each.\nType and parameters are public, but otherwise the interface is defined by split_each, \n\n\n\n\n\n"},{"title":"MemoryViews.Immutable","page":"Reference","location":"reference/#MemoryViews.Immutable","category":"type","text":"Trait struct, only used in the mutability parameter of MemoryView\n\n\n\n\n\n"},{"title":"MemoryViews.IsMemory","page":"Reference","location":"reference/#MemoryViews.IsMemory","category":"type","text":"IsMemory{T <: MemoryView} <: MemoryKind\n\nSee: MemoryKind\n\n\n\n\n\n"},{"title":"MemoryViews.MemoryKind","page":"Reference","location":"reference/#MemoryViews.MemoryKind","category":"type","text":"MemoryKind\n\nTrait object used to signal if values of a type is semantically equal to their own MemoryView.\nIf so, MemoryKind(T) should return an instance of IsMemory,\nelse NotMemory(). The default implementation MemoryKind(::Type) returns NotMemory().\n\nIf MemoryKind(T) isa IsMemory{M}, the following must hold:\n\nM is a concrete subtype of MemoryView. To obtain M from an m::IsMemory{M},\n use inner(m).\nMemoryView(::T) is a valid instance of M (except in cases where there can be invalid\ninstances of T that instead errors, e.g. uninitialized instances).\nMemoryView(x) == x for all instances x::T\n\nSome objects can be turned into MemoryView without being IsMemory.\nFor example, MemoryView(::String) returns a valid MemoryView even though\nMemoryKind(String) === NotMemory().\nThis is because strings have different semantics than memory views - the latter\nis a dense AbstractArray while strings are not, and so the fourth requirement\nMemoryView(x::String) == x does not hold.\n\nSee also: MemoryView\n\n\n\n\n\n"},{"title":"MemoryViews.MemoryView","page":"Reference","location":"reference/#MemoryViews.MemoryView","category":"type","text":"MemoryView{T, M} <: DenseVector{T}\n\nView into a Memory{T}.\nConstruct from memory-backed values x with MemoryView(x).\n\nMemoryViews are guaranteed to point to contiguous, valid CPU memory,\nexcept where they have size zero.\n\nThe parameter M controls the mutability of the memory view,\nand may be Mutable or Immutable, corresponding to the\nthe aliases MutableMemoryView{T} and ImmutableMemoryView{T}.\n\nSee also: MemoryKind\n\nExamples\n\njulia> v = view([1, 2, 3, 4], 2:3);\n\njulia> mem = MemoryView(v)\n2-element MutableMemoryView{Int64}:\n 2\n 3\n\njulia> MemoryView(codeunits(\"abc\")) isa ImmutableMemoryView{UInt8}\ntrue\n\nExtended help\n\nNew types T which are backed by dense memory should implement:\n\nMemoryView(x::T) to construct a memory view from x. This should\n always return a MutableMemoryView when the memory of x is mutable.\nMemoryKind(x::T), if T is semantically equal to its own memory view.\nExamples of this include Vector, Memory, and\nBase.CodeUnits{UInt8, String}. If so, x == MemoryView(x) should hold.\n\nIf MemoryView(x) is implemented, then ImmutableMemoryView(x) will\nautomatically work, even if MemoryView(x) returns a mutable view.\n\nIt is not possible to mutate memory though an ImmutableMemoryView, but the existence\nof the view does not protect the same memory from being mutated though another\nvariable, or through explicitly unsafe functions.\n\nThe precise memory layout of the data in a MemoryView follows that of Memory.\nThis includes the fact that some elements in the array, such as  Strings,\nmay be stored as pointers, and [isbits Union optimisations]\n(https://docs.julialang.org/en/v1/devdocs/isbitsunionarrays/).\n\n\n\n\n\n"},{"title":"MemoryViews.Mutable","page":"Reference","location":"reference/#MemoryViews.Mutable","category":"type","text":"Trait struct, only used in the mutability parameter of MemoryView\n\n\n\n\n\n"},{"title":"MemoryViews.NotMemory","page":"Reference","location":"reference/#MemoryViews.NotMemory","category":"type","text":"NotMemory <: MemoryKind\n\nSee: MemoryKind\n\n\n\n\n\n"},{"title":"MemoryViews.inner","page":"Reference","location":"reference/#MemoryViews.inner-Union{Tuple{IsMemory{T}}, Tuple{T}} where T","category":"method","text":"inner(::IsMemory{T})\n\nReturn T from an IsMemory{T}.\n\nSee: MemoryKind\n\n\n\n\n\n"},{"title":"MemoryViews.split_at","page":"Reference","location":"reference/#MemoryViews.split_at-Tuple{MemoryView, Int64}","category":"method","text":"split_at(v::T, i::Int) -> Tuple{T, T} where {T <: MemoryView}\n\nSplit a memory view into two at an index.\n\nThe first will contain all indices in 1:i-1, the second i:end.\nThis function will throw a BoundsError if i is not in 1:end+1.\n\nExamples\n\njulia> split_at(MemoryView([1,2,3,4,5]), 2)\n([1], [2, 3, 4, 5])\n\njulia> split_at(MemoryView(Int8[1, 2, 3]), 4)\n(Int8[1, 2, 3], Int8[])\n\n\n\n\n\n"},{"title":"MemoryViews.split_each","page":"Reference","location":"reference/#MemoryViews.split_each-Union{Tuple{T}, Tuple{Any, T}} where T","category":"method","text":"split_each(data, x::T)\n\nReturn an iterator over memory-backed data data of eltype T.\nReturns MemoryViews of the same elements as data, separated by by x.\nItems are compared by isequal.\n\nAn empty input data yields no elements. Empty elements are otherwise\nyielded.\n\nExamples\n\njulia> split_each(b\"abbc\", UInt8('b')) |> collect |> print\nImmutableMemoryView{UInt8}[[0x61], [], [0x63]]\n\njulia> split_each(b\"babceb\", UInt8('b')) |> collect |> print\nImmutableMemoryView{UInt8}[[], [0x61], [0x63, 0x65], []]\n\njulia> split_each(UInt8[], UInt8('b')) |> collect |> print\nMutableMemoryView{UInt8}[]\n\n\n\n\n\n"},{"title":"MemoryViews.split_first","page":"Reference","location":"reference/#MemoryViews.split_first-Tuple{MemoryView}","category":"method","text":"split_first(v::MemoryView{T}) -> Tuple{T, MemoryView{T}}\n\nReturn the first element of v and all other elements as a new memory view.\n\nThis function will throw a BoundsError if v is empty.\n\nSee also: split_last\n\nExamples\n\njulia> v = MemoryView([0x01, 0x02, 0x03]);\n\njulia> split_first(v)\n(0x01, UInt8[0x02, 0x03])\n\njulia> split_first(v[1:1])\n(0x01, UInt8[])\n\njulia> split_first(v[1:0])\nERROR: BoundsError: attempt to access 0-element MutableMemoryView{UInt8} at index [1]\n[...]\n\n\n\n\n\n"},{"title":"MemoryViews.split_last","page":"Reference","location":"reference/#MemoryViews.split_last-Tuple{MemoryView}","category":"method","text":"split_last(v::MemoryView{T}) -> Tuple{T, MemoryView{T}}\n\nReturn the last element of v and all other elements as a new memory view.\n\nThis function will throw a BoundsError if v is empty.\n\nSee also: split_first\n\nExamples\n\njulia> v = MemoryView([0x01, 0x02, 0x03]);\n\njulia> split_last(v)\n(0x03, UInt8[0x01, 0x02])\n\njulia> split_last(v[1:1])\n(0x01, UInt8[])\n\njulia> split_last(v[1:0])\nERROR: BoundsError: attempt to access 0-element MutableMemoryView{UInt8} at index [1]\n[...]\n\n\n\n\n\n"},{"title":"MemoryViews.split_unaligned","page":"Reference","location":"reference/#MemoryViews.split_unaligned-Union{Tuple{M}, Tuple{T}, Tuple{A}, Tuple{MemoryView{T, M}, Val{A}}} where {A, T, M}","category":"method","text":"split_unaligned(v::T, ::Val{A}) -> Tuple{T, T} where {T <: MemoryView}\n\nSplit memory view v into two views a and b, where a is the smallest prefix of v\nthat guarantees the starting memory address of b is is aligned to the integer value A.\nA must be a normal bit-integer, and a power of two in the range 1:64.\n\nIf v is empty or already aligned, a will be empty.\nIf no elements of v is aligned, b will be empty and a will be equal to v.\nThe element type of v must be a bitstype.\n\nwarning: Warning\nWhen using this function, make sure to GC.@preserve v, to make sure Julia\ndoes not move v in memory.\n\nExamples:\n\njulia> split_unaligned(MemoryView(Int16[1, 2, 3]), Val(8))\n(Int16[], Int16[1, 2, 3])\n\njulia> split_unaligned(MemoryView(collect(0x01:0x20))[6:13], Val(8))\n(UInt8[0x06, 0x07, 0x08], UInt8[0x09, 0x0a, 0x0b, 0x0c, 0x0d])\n\n\n\n\n\n"},{"title":"MemoryViews.unsafe_from_parts","page":"Reference","location":"reference/#MemoryViews.unsafe_from_parts-Tuple{MemoryRef, Int64}","category":"method","text":"unsafe_from_parts(ref::MemoryRef{T}, len::Int)::MutableMemoryView{T}\n\nCreate a mutable memory view from its parts.\n\nSafety: Callers are responsible to ensure that:\n\nlen is not negative\nAll indices i in 1:len are valid for ref (i.e. memoryref(ref, i) would\nnot throw)\nIf ref is derived from immutable memory, the returned memory view must not\nbe mutated. The caller should immediately convert it to an immutable view.\n\nExamples\n\njulia> v = [1,2,3,4];\n\njulia> ref = Base.cconvert(Ptr, v);\n\njulia> view = unsafe_from_parts(ref, 3)\n3-element MutableMemoryView{Int64}:\n 1\n 2\n 3\n\n\n\n\n\n"},{"title":"MemoryViews in interfaces","page":"MemoryViews in interfaces","location":"interfaces/#MemoryViews-in-interfaces","category":"section","text":"The intended purpose of the MemoryView type is to ease manipulation of memory-backed objects through a kind of low-level abstraction.\nStrings, substrings, Memory, dense views of Matrix and countless other types all have the same data representation, namely as simply a chunk of memory.\nThis means they share important properties: Searching for a one-byte Char inside a String needs to ccall the exact same memchr as searching for Int8 in a subarray of Memory.\nLikewise, checking that two substrings are equal can use the same implementation as code checking that two bytearrays are equal.\nObviously, writing the same implementation for each of these types is wasteful.\n\nUnfortunately, Julia's system of abstract types are poorly equipped to handle this.\nThis is because abstract types represent shared behaviour, whereas in this case, what unites these many different types are the underlying representation - exactly the thing that abstract types want to paper over!\n\nMemoryViews.jl addresses this by introducing two types: At the bottom of abstraction, the simple MemoryView type is most basic, unified instantiation of the underlying representation (a chunk of memory).\nAt the top, the MemoryKind trait controls dispatch such that the low-level MemoryView implementation is called for the right types.\nThe idea is that whenever you write a method that operates on \"just\" a chunk of memory, you implement it for MemoryView.\nThen, you write methods with MemoryKind to make sure all the proper function calls gets dispatched to your MemoryView implementation.\n\ntip: Tip\nEven if you only ever intend a method to work for, say, Vector, it can still be a good idea to implement it for MemoryView.\nFirst, it makes it explicit that you only use Vector for its properties as a chunk of memory, and not for, say, its ability\nto be resized.\nSecond, you can implement the method for ImmutableMemoryView, letting both caller and callee know that the argument is not being mutated.\nThird, after implementing your method for MemoryView, it may be easy to also make your method work for Memory and other memory-backed types!"},{"title":"The MemoryKind trait","page":"MemoryViews in interfaces","location":"interfaces/#The-MemoryKind-trait","category":"section","text":"MemoryKind answers the question: Can instances of a type be treated as equal to its own memory view?\nFor a type T, MemoryKind(T) returns one of two types:\n\nNotMemory() if Ts are not equivalent to its own memory. Examples include Int, which has no memory representation because\nthey are not heap allocated, and String, which are backed by memory, but which are semantically different from an AbstractVector\ncontaining its bytes.\nIsMemory{M}() where M is a concrete subtype of MemoryView, if instances of T are equivalent to their own memory.\nExamples include Arrays and Codeunits{String}. For these objects, it's the case that x == MemoryView(x).\n\njulia> MemoryKind(Vector{Union{Int32, UInt32}})\nIsMemory{MutableMemoryView{Union{Int32, UInt32}}}()\n\njulia> MemoryKind(Matrix{String})\nIsMemory{MutableMemoryView{String}}()\n\njulia> MemoryKind(SubString{String})\nNotMemory()"},{"title":"Implementing MemoryView interfaces","page":"MemoryViews in interfaces","location":"interfaces/#Implementing-MemoryView-interfaces","category":"section","text":"When implementing a method that has a fast-past for memory-like types, you typically want to\n\nAt the top level, dispatch on MemoryKind of your argument to funnel the memory-like objects into\nyour optimised MemoryView function\nAt the low level, use MemoryView for the implementation of the optimised version\n\nAn example could be:\n\n# Dispatch on `MemoryKind`\nmy_hash(x) = my_hash(MemoryKind(typeof(x)), x)\n\n# For objects that are bytes, call the function taking only the memory\n# representation of `x`\nmy_hash(::IsMemory{<:MemoryView{UInt8}}, x) = my_hash(ImmutableMemoryView(x))\n\n# IsMemory with eltype other than UInt8 can't use the fast low-level function\nmy_hash(T::IsMemory, x) = my_hash(NotMemory(), x)\n\nfunction my_hash(::NotMemory, x)\n    # fallback implementation\nend\n\nfunction my_hash(mem::ImmutableMemoryView{UInt8})\n    # some optimised low-level memory manipulation with `mem` of bytes\nend\n\n# Handle e.g. strings separately, since they are not semantically equal to\n# an array of elements in memory, but for this method in particular,\n# we want to treat strings as if they are.\nfunction my_hash(x::Union{String, SubString{String}})\n    my_hash(MemoryView(x))\nend"},{"title":"MemoryViews.jl","page":"MemoryViews in Base","location":"base/#MemoryViews.jl","category":"section","text":"It is my hope that MemoryViews, or something like MemoryViews, will eventually\nbe moved into Base Julia.\nThis is because Base Julia, too, includes code that uses the concept of a memory-backed array.\nHowever, Base currently lacks any kind of interface and internal API to handle memory-backed objects.\n\nSee the related issue on JuliaLang/julia."},{"title":"What's wrong with SubArrays of Memory as memory views?","page":"MemoryViews in Base","location":"base/#What's-wrong-with-SubArrays-of-Memory-as-memory-views?","category":"section","text":"SubArray is generic over too much, and is therefore too hard to reason about,\nand to uphold its guarantees.\n\nFirst, it's generic over the array type, meaning it may be backed by Memory or Vector, but also UnitRange or Base.LogRange (bitstypes, so not backed by memory), BitMatrix (memory-backed, but elements are stored packed), OffsetArrays, CodeUnits (memory-backed but immutable) and many more.\nWhat can you do with the underlying array, generally speaking? Take a pointer to it? No. Assume one-based indexing? No. Assume a stride of one? No. Assume mutability? No.\n\nSecond, it's generic over the index type. It may be UnitRange{Int}, of course, but also Base.OneTo{UInt16}, or StepRange{BigInteger}, CartesianIndices (which it itself generic over the indexes), Colon.\nCan you define the subset of these types which indicate dense indices? I can't.\n\nThird, it's multidimensional. It may collect to a Vector or Matrix.\n\nThis is not a design flaw of SubArray - it's a perfectly fine design choice, which enables SubArray to be extremely flexible and broadly useful.\nUnfortunately, it also makes it nearly impossible to write robust, low-level code using SubArray, because it's almost impossible not to violate the assumptions of a subset of SubArrays many concrete types.\nPractically speaking, what happens is that methods taking SubArray fall back to only assuming what can be assumed about AbstractArray - which may be inefficient, and buggy (as the recurring bugs due to assumption of one-based indexing has taught us).\n\nIn contrast, a MemoryView{T} is always represented by exactly a MemoryRef{T} and an Int as length.\nYou know exactly what you get."},{"title":"Design decisions","page":"MemoryViews in Base","location":"base/#Design-decisions","category":"section","text":""},{"title":"Mutability","page":"MemoryViews in Base","location":"base/#Mutability","category":"section","text":"Mutable and immutable memory views are statically distinguished, such that users\ncan write methods that only take mutable memory views.\nThis will statically prevent users from accidentally mutating e.g. strings."},{"title":"MemoryKind","page":"MemoryViews in Base","location":"base/#MemoryKind","category":"section","text":"The MemoryKind trait is used because constructing a MemoryView only for dispatch purposes\nmay not be able to be optimised away by the compiler for some types (currently, strings).\n\nMemoryKind could be replaced with a function that returned nothing, or the correct\nMemoryView type directly, but it's nicer to dispatch on ::MemoryKind than on ::Union{Nothing, Type{<:MemoryView}}."},{"title":"Limitations","page":"MemoryViews in Base","location":"base/#Limitations","category":"section","text":"Many optimised fast methods for more established types like Vector are missing for MemoryView.\nThese are added over time. Please make an issue or a PR as you encounter missing methods.\nCurrently, MemoryView does not make use of Core.GenericMemory's additional parameters, such as atomicity or address space.\nThis may easily be added with a GenericMemoryView type, similar to Memory / GenericMemory.\nCurrently, Strings are not backed by Memory in Julia. Therefore, creating a MemoryView of a string\nrequires heap-allocating a new Memory pointing to the existing memory of the string.\nThis can be fixed if String is re-implemented to be backed by Memory, but I don't know\nenough details about the implementation of String to know if this is practical."},{"title":"Alternative proposal","page":"MemoryViews in Base","location":"base/#Alternative-proposal","category":"section","text":"In examples/alternative.jl, there is an implementation where a MemoryView is just a pointer and a length.\nThis makes it nearly identical to Random.UnsafeView, however, compared to UnsafeView, this proposal has:\n\nThe MemoryKind trait, useful to control dispatch to functions that can treat arrays as being memory\nThe distinction between mutable and immutable memory views\n\nOverall, I like the alternative proposal less. Raw pointers are bad for safety and ergonomics, and they interact\nless nicely with the Julia runtime. Also, the existing GenericMemoryRef is essentially perfect for this purpose."},{"title":"Advantages","page":"MemoryViews in Base","location":"base/#Advantages","category":"section","text":"Pointer-based memviews are cheaper to construct, and do not allocate for strings, unlike Memory.\nPerhaps in the future, strings too will be backed by Memory.\nPointer-based memory views allows interoperability with non-Julia memory like C owned structs easier."},{"title":"Disadvantages","page":"MemoryViews in Base","location":"base/#Disadvantages","category":"section","text":"While some low-level methods using MemoryView will just forward to calling external libraries where\nusing a pointer is fine, many will be written in pure Julia. There, it's less nice to have raw pointers.\nCode using pointer-based memviews must make sure to only have the views exist inside GC.@preserve blocks,\nwhich is annoying and will almost certainly be violated accidentally somewhere\nWe can't use advantages of the existing Memory infrastructure, e.g. having a GenericMemRef which supports\natomic memory."},{"title":"MemoryViews.jl","page":"MemoryViews","location":"#MemoryViews.jl","category":"section","text":"This package provide the MemoryView type, which is a lightweight and simple view into Memory.\nThe MemoryView type is a useful low-level building block for code that operates on chunks of memory."},{"title":"Features:","page":"MemoryViews","location":"#Features:","category":"section","text":"Simple and easy to reason about\nLow-overhead, efficient methods\nA safer alternative to pointers\n\nThe MemoryView type has the following layout:\n\nstruct MemoryView{T, M} <: DenseVector{T}\n    ref::MemoryRef{T},\n    len::Int\nend\n\nThe M parameter is either Mutable or Immutable, which are unexported but public types defined in this package.\nMemoryViews also provide the following aliases for convenience:\n\nconst MutableMemoryView{T} = MemoryView{T, Mutable}\nconst ImmutableMemoryView{T} = MemoryView{T, Immutable}\n\nImmutable memory views are immutable, in that they do not support setindex! or other\nmutating methods. The existence of an ImmutableMemoryView does not protect its underlying\ndata from being mutated through another variable, or though explicitly unsafe functions,\nsuch as using raw pointers."},{"title":"Usage","page":"MemoryViews","location":"#Usage","category":"section","text":""},{"title":"Constructing memory views","page":"MemoryViews","location":"#Constructing-memory-views","category":"section","text":"Construct memory views from x with MemoryView(x).\nMemoryViews should be constructable from any type that is stored as an array densely in memory.\nIt can also be constructed from other non-array types that are represented by a chunk of memory (like a String).\nBy default, constructors exists for the memory-backed types in Base:\n\n# Vectors\n@assert MemoryView([\"a\", \"b\", \"c\"]) isa MemoryView\n\n# Strings\n@assert MemoryView(\"abc\") isa MemoryView\n\n# Even complex nested memory-backed types\n@assert MemoryView(view(codeunits(view(\"abcd\", Base.OneTo(2))), :)) isa MemoryView\n\nFor values x that are mutable such as Memorys and Arrays (and SubArrays of those),\nMemoryView(x) return MutableMemoryView:\n\n@assert MemoryView(Int32[1,2,3]) isa MutableMemoryView{Int32}\n@assert MemoryView(Memory{String}(undef, 3)) isa MutableMemoryView{String}\n\nFor values that are immutable, MemoryView return ImmutableMemoryViews:\n\n@assert MemoryView(\"abc\") isa ImmutableMemoryView{UInt8}\n\nThe constructor ImmutableMemoryView(x) will construct an immutable view no matter\nif the type returned by MemoryView(x) is mutable or not.\nThis is because it's always possible to convert a mutable memory view to an immutable one:\n\n@assert MemoryView(UInt[]) isa MutableMemoryView{UInt}\n@assert ImmutableMemoryView(UInt[]) isa ImmutableMemoryView{UInt}\n\nHence, when adding new constructors for new types, you should only add\nmethods to MemoryView.\nThis should return a mutable memview where possible."},{"title":"Indexing","page":"MemoryViews","location":"#Indexing","category":"section","text":"MemoryView{T} is a subtype of AbstractVector{T}, and mostly behave like you would expect\nan abstract vector to behave w.r.t. indexing:\n\nmem = MemoryView([1,2,3,4,5,6,7,8])\n\nprintln(mem[2])\nprintln(mem[2:4])\nprintln(mem[end])\nprintln(mem[:])\n\n# output\n2\n[2, 3, 4]\n8\n[1, 2, 3, 4, 5, 6, 7, 8]\n\nOne exception is slicing, which does not copy the underlying data, but simply\nreturns a new view of the same data.\nTo copy explicitly, use copy, which will create a new MemoryView that looks\ninto a copy of the underlying data:\n\nmem1 = MemoryView([1,2,3])\nmem2 = mem1[1:3]\nmem3 = copy(mem1)\nmem1[1] = 3\nprintln(mem2[1])\nprintln(mem3[1])\n\n# output\n3\n1"}]
}
