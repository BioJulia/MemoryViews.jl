var documenterSearchIndex = {"docs":
[{"title":"Reference","page":"Reference","location":"reference/#Reference","category":"section","text":""},{"title":"MemoryViews.DelimitedIterator","page":"Reference","location":"reference/#MemoryViews.DelimitedIterator","category":"type","text":"Iterator struct created by split_each. Type and parameters are public, but otherwise the interface is defined by split_each, \n\n\n\n\n\n"},{"title":"MemoryViews.Immutable","page":"Reference","location":"reference/#MemoryViews.Immutable","category":"type","text":"Trait struct, only used in the mutability parameter of MemoryView\n\n\n\n\n\n"},{"title":"MemoryViews.IsMemory","page":"Reference","location":"reference/#MemoryViews.IsMemory","category":"type","text":"IsMemory{T <: MemoryView} <: MemoryKind\n\nSee: MemoryKind\n\n\n\n\n\n"},{"title":"MemoryViews.MemoryKind","page":"Reference","location":"reference/#MemoryViews.MemoryKind","category":"type","text":"MemoryKind\n\nTrait object used to signal if values of a type is semantically equal to their own MemoryView. If so, MemoryKind(T) should return an instance of IsMemory, else NotMemory(). The default implementation MemoryKind(::Type) returns NotMemory().\n\nIf MemoryKind(T) isa IsMemory{M}, the following must hold:\n\nM is a concrete subtype of MemoryView. To obtain M from an m::IsMemory{M},  use inner(m).\nMemoryView(::T) is a valid instance of M (except in cases where there can be invalid instances of T that instead errors, e.g. uninitialized instances).\nMemoryView(x) == x for all instances x::T\n\nSome objects can be turned into MemoryView without being IsMemory. For example, MemoryView(::String) returns a valid MemoryView even though MemoryKind(String) === NotMemory(). This is because strings have different semantics than memory views - the latter is a dense AbstractArray while strings are not, and so the fourth requirement MemoryView(x::String) == x does not hold.\n\nSee also: MemoryView\n\n\n\n\n\n"},{"title":"MemoryViews.MemoryView","page":"Reference","location":"reference/#MemoryViews.MemoryView","category":"type","text":"MemoryView{T, M} <: DenseVector{T}\n\nView into a Memory{T}. Construct from memory-backed values x with MemoryView(x).\n\nMemoryViews are guaranteed to point to contiguous, valid CPU memory, except where they have size zero.\n\nThe parameter M controls the mutability of the memory view, and may be Mutable or Immutable, corresponding to the the aliases MutableMemoryView{T} and ImmutableMemoryView{T}.\n\nSee also: MemoryKind\n\nExamples\n\njulia> v = view([1, 2, 3, 4], 2:3);\n\njulia> mem = MemoryView(v)\n2-element MutableMemoryView{Int64}:\n 2\n 3\n\njulia> MemoryView(codeunits(\"abc\")) isa ImmutableMemoryView{UInt8}\ntrue\n\nExtended help\n\nNew types T which are backed by dense memory should implement:\n\nMemoryView(x::T) to construct a memory view from x. This should  always return a MutableMemoryView when the memory of x is mutable.\nMemoryKind(x::T), if T is semantically equal to its own memory view. Examples of this include Vector, Memory, and Base.CodeUnits{UInt8, String}. If so, x == MemoryView(x) should hold.\n\nIf MemoryView(x) is implemented, then ImmutableMemoryView(x) will automatically work, even if MemoryView(x) returns a mutable view.\n\nIt is not possible to mutate memory though an ImmutableMemoryView, but the existence of the view does not protect the same memory from being mutated though another variable, or through explicitly unsafe functions.\n\nThe precise memory layout of the data in a MemoryView follows that of Memory. This includes the fact that some elements in the array, such as  Strings, may be stored as pointers, and isbits Union optimisations.\n\n\n\n\n\n"},{"title":"MemoryViews.Mutable","page":"Reference","location":"reference/#MemoryViews.Mutable","category":"type","text":"Trait struct, only used in the mutability parameter of MemoryView\n\n\n\n\n\n"},{"title":"MemoryViews.MutableMemoryView","page":"Reference","location":"reference/#MemoryViews.MutableMemoryView-Union{Tuple{T}, Tuple{MemoryViews.Unsafe, MemoryView{T}}} where T","category":"method","text":"MutableMemoryView(::Unsafe, x::MemoryView)\n\nConvert a memory view into a mutable memory view. Note that it may cause undefined behaviour, if supposedly immutable data is observed to be mutated.\n\n\n\n\n\n"},{"title":"MemoryViews.NotMemory","page":"Reference","location":"reference/#MemoryViews.NotMemory","category":"type","text":"NotMemory <: MemoryKind\n\nSee: MemoryKind\n\n\n\n\n\n"},{"title":"MemoryViews.Unsafe","page":"Reference","location":"reference/#MemoryViews.Unsafe","category":"type","text":"Unsafe\n\nTrait object used to dispatch to unsafe methods. The MemoryViews.unsafe instance is the singleton instance of this type.\n\n\n\n\n\n"},{"title":"MemoryViews.inner","page":"Reference","location":"reference/#MemoryViews.inner-Union{Tuple{IsMemory{T}}, Tuple{T}} where T","category":"method","text":"inner(::IsMemory{T})\n\nReturn T from an IsMemory{T}.\n\nSee: MemoryKind\n\n\n\n\n\n"},{"title":"MemoryViews.split_at","page":"Reference","location":"reference/#MemoryViews.split_at-Tuple{MemoryView, Int64}","category":"method","text":"split_at(v::T, i::Int) -> Tuple{T, T} where {T <: MemoryView}\n\nSplit a memory view into two at an index.\n\nThe first will contain all indices in 1:i-1, the second i:end. This function will throw a BoundsError if i is not in 1:end+1.\n\nExamples\n\njulia> split_at(MemoryView([1,2,3,4,5]), 2)\n([1], [2, 3, 4, 5])\n\njulia> split_at(MemoryView(Int8[1, 2, 3]), 4)\n(Int8[1, 2, 3], Int8[])\n\n\n\n\n\n"},{"title":"MemoryViews.split_each","page":"Reference","location":"reference/#MemoryViews.split_each-Union{Tuple{T}, Tuple{Any, T}} where T","category":"method","text":"split_each(data, x::T)\n\nReturn an iterator over memory-backed data data of eltype T. Returns MemoryViews of the same elements as data, separated by by x. Items are compared by isequal.\n\nAn empty input data yields no elements. Empty elements are otherwise yielded.\n\nExamples\n\njulia> split_each(b\"abbc\", UInt8('b')) |> collect |> print\nImmutableMemoryView{UInt8}[[0x61], [], [0x63]]\n\njulia> split_each(b\"babceb\", UInt8('b')) |> collect |> print\nImmutableMemoryView{UInt8}[[], [0x61], [0x63, 0x65], []]\n\njulia> split_each(UInt8[], UInt8('b')) |> collect |> print\nMutableMemoryView{UInt8}[]\n\n\n\n\n\n"},{"title":"MemoryViews.split_first","page":"Reference","location":"reference/#MemoryViews.split_first-Tuple{MemoryView}","category":"method","text":"split_first(v::MemoryView{T}) -> Tuple{T, MemoryView{T}}\n\nReturn the first element of v and all other elements as a new memory view.\n\nThis function will throw a BoundsError if v is empty.\n\nSee also: split_last\n\nExamples\n\njulia> v = MemoryView([0x01, 0x02, 0x03]);\n\njulia> split_first(v)\n(0x01, UInt8[0x02, 0x03])\n\njulia> split_first(v[1:1])\n(0x01, UInt8[])\n\njulia> split_first(v[1:0])\nERROR: BoundsError: attempt to access 0-element MutableMemoryView{UInt8} at index [1]\n[...]\n\n\n\n\n\n"},{"title":"MemoryViews.split_last","page":"Reference","location":"reference/#MemoryViews.split_last-Tuple{MemoryView}","category":"method","text":"split_last(v::MemoryView{T}) -> Tuple{T, MemoryView{T}}\n\nReturn the last element of v and all other elements as a new memory view.\n\nThis function will throw a BoundsError if v is empty.\n\nSee also: split_first\n\nExamples\n\njulia> v = MemoryView([0x01, 0x02, 0x03]);\n\njulia> split_last(v)\n(0x03, UInt8[0x01, 0x02])\n\njulia> split_last(v[1:1])\n(0x01, UInt8[])\n\njulia> split_last(v[1:0])\nERROR: BoundsError: attempt to access 0-element MutableMemoryView{UInt8} at index [1]\n[...]\n\n\n\n\n\n"},{"title":"MemoryViews.split_unaligned","page":"Reference","location":"reference/#MemoryViews.split_unaligned-Union{Tuple{A}, Tuple{MemoryView, Val{A}}} where A","category":"method","text":"split_unaligned(v::T, ::Val{A}) -> Tuple{T, T} where {T <: MemoryView}\n\nSplit memory view v into two views a and b, where a is the smallest prefix of v that guarantees the starting memory address of b is is aligned to the integer value A. A must be a normal bit-integer, and a power of two in the range 1:64.\n\nIf v is empty or already aligned, a will be empty. If no elements of v is aligned, b will be empty and a will be equal to v. The element type of v must be a bitstype.\n\nExamples:\n\njulia> split_unaligned(MemoryView(Int16[1, 2, 3]), Val(8))\n(Int16[], Int16[1, 2, 3])\n\njulia> split_unaligned(MemoryView(collect(0x01:0x20))[6:13], Val(8))\n(UInt8[0x06, 0x07, 0x08], UInt8[0x09, 0x0a, 0x0b, 0x0c, 0x0d])\n\n\n\n\n\n"},{"title":"MemoryViews.unsafe_from_parts","page":"Reference","location":"reference/#MemoryViews.unsafe_from_parts-Union{Tuple{T}, Tuple{MemoryRef{T}, Int64}} where T","category":"method","text":"unsafe_from_parts(ref::MemoryRef{T}, len::Int)::MutableMemoryView{T}\n\nCreate a mutable memory view from its parts.\n\nSafety: Callers are responsible to ensure that:\n\nlen is not negative\nAll indices i in 1:len are valid for ref (i.e. memoryref(ref, i) would not throw)\nIf ref is derived from immutable memory, the returned memory view must not be mutated. The caller should immediately convert it to an immutable view.\n\nExamples\n\njulia> v = [1,2,3,4];\n\njulia> ref = Base.cconvert(Ptr, v);\n\njulia> view = unsafe_from_parts(ref, 3)\n3-element MutableMemoryView{Int64}:\n 1\n 2\n 3\n\n\n\n\n\n"},{"title":"MemoryViews in interfaces","page":"MemoryViews in interfaces","location":"interfaces/#MemoryViews-in-interfaces","category":"section","text":""},{"title":"MemoryViews in interfaces","page":"MemoryViews in interfaces","location":"interfaces/","category":"page","text":"The intended purpose of the MemoryView type is to ease manipulation of memory-backed objects through a kind of low-level abstraction. Strings, substrings, Memory, dense views of Matrix and countless other types all have the same data representation, namely as simply a chunk of memory. This means they share important properties: Searching for a one-byte Char inside a String needs to ccall the exact same memchr as searching for Int8 in a subarray of Memory. Likewise, checking that two substrings are equal can use the same implementation as code checking that two bytearrays are equal. Obviously, writing the same implementation for each of these types is wasteful."},{"title":"MemoryViews in interfaces","page":"MemoryViews in interfaces","location":"interfaces/","category":"page","text":"Unfortunately, Julia's system of abstract types are poorly equipped to handle this. This is because abstract types represent shared behaviour, whereas in this case, what unites these many different types are the underlying representation - exactly the thing that abstract types want to paper over!"},{"title":"MemoryViews in interfaces","page":"MemoryViews in interfaces","location":"interfaces/","category":"page","text":"MemoryViews.jl addresses this by introducing two types: At the bottom of abstraction, the simple MemoryView type is most basic, unified instantiation of the underlying representation (a chunk of memory). At the top, the MemoryKind trait controls dispatch such that the low-level MemoryView implementation is called for the right types. The idea is that whenever you write a method that operates on \"just\" a chunk of memory, you implement it for MemoryView. Then, you write methods with MemoryKind to make sure all the proper function calls gets dispatched to your MemoryView implementation."},{"title":"MemoryViews in interfaces","page":"MemoryViews in interfaces","location":"interfaces/","category":"page","text":"tip: Tip\nEven if you only ever intend a method to work for, say, Vector, it can still be a good idea to implement it for MemoryView. First, it makes it explicit that you only use Vector for its properties as a chunk of memory, and not for, say, its ability to be resized. Second, you can implement the method for ImmutableMemoryView, letting both caller and callee know that the argument is not being mutated. Third, after implementing your method for MemoryView, it may be easy to also make your method work for Memory and other memory-backed types!"},{"title":"The MemoryKind trait","page":"MemoryViews in interfaces","location":"interfaces/#The-MemoryKind-trait","category":"section","text":""},{"title":"MemoryViews in interfaces","page":"MemoryViews in interfaces","location":"interfaces/","category":"page","text":"MemoryKind answers the question: Can instances of a type be treated as equal to its own memory view? For a type T, MemoryKind(T) returns one of two types:"},{"title":"MemoryViews in interfaces","page":"MemoryViews in interfaces","location":"interfaces/","category":"page","text":"NotMemory() if Ts are not equivalent to its own memory. Examples include Int, which has no memory representation because they are not heap allocated, and String, which are backed by memory, but which are semantically different from an AbstractVector containing its bytes.\nIsMemory{M}() where M is a concrete subtype of MemoryView, if instances of T are equivalent to their own memory. Examples include Arrays and Codeunits{String}. For these objects, it's the case that x == MemoryView(x)."},{"title":"MemoryViews in interfaces","page":"MemoryViews in interfaces","location":"interfaces/","category":"page","text":"julia> MemoryKind(Vector{Union{Int32, UInt32}})\nIsMemory{MutableMemoryView{Union{Int32, UInt32}}}()\n\njulia> MemoryKind(Matrix{String})\nIsMemory{MutableMemoryView{String}}()\n\njulia> MemoryKind(SubString{String})\nNotMemory()"},{"title":"Implementing MemoryView interfaces","page":"MemoryViews in interfaces","location":"interfaces/#Implementing-MemoryView-interfaces","category":"section","text":""},{"title":"MemoryViews in interfaces","page":"MemoryViews in interfaces","location":"interfaces/","category":"page","text":"When implementing a method that has a fast-past for memory-like types, you typically want to"},{"title":"MemoryViews in interfaces","page":"MemoryViews in interfaces","location":"interfaces/","category":"page","text":"At the top level, dispatch on MemoryKind of your argument to funnel the memory-like objects into your optimised MemoryView function\nAt the low level, use MemoryView for the implementation of the optimised version"},{"title":"MemoryViews in interfaces","page":"MemoryViews in interfaces","location":"interfaces/","category":"page","text":"An example could be:"},{"title":"MemoryViews in interfaces","page":"MemoryViews in interfaces","location":"interfaces/","category":"page","text":"# Dispatch on `MemoryKind`\nmy_hash(x) = my_hash(MemoryKind(typeof(x)), x)\n\n# For objects that are bytes, call the function taking only the memory\n# representation of `x`\nmy_hash(::IsMemory{<:MemoryView{UInt8}}, x) = my_hash(ImmutableMemoryView(x))\n\n# IsMemory with eltype other than UInt8 can't use the fast low-level function\nmy_hash(T::IsMemory, x) = my_hash(NotMemory(), x)\n\nfunction my_hash(::NotMemory, x)\n    # fallback implementation\nend\n\nfunction my_hash(mem::ImmutableMemoryView{UInt8})\n    # some optimised low-level memory manipulation with `mem` of bytes\nend\n\n# Handle e.g. strings separately, since they are not semantically equal to\n# an array of elements in memory, but for this method in particular,\n# we want to treat strings as if they are.\nfunction my_hash(x::Union{String, SubString{String}})\n    my_hash(MemoryView(x))\nend"},{"title":"MemoryViews.jl","page":"MemoryViews in Base","location":"base/#MemoryViews.jl","category":"section","text":""},{"title":"MemoryViews in Base","page":"MemoryViews in Base","location":"base/","category":"page","text":"It is my hope that MemoryViews, or something like MemoryViews, will eventually be moved into Base Julia. This is because Base Julia, too, includes code that uses the concept of a memory-backed array. However, Base currently lacks any kind of interface and internal API to handle memory-backed objects."},{"title":"MemoryViews in Base","page":"MemoryViews in Base","location":"base/","category":"page","text":"See the related issue on JuliaLang/julia."},{"title":"What's wrong with SubArrays of Memory as memory views?","page":"MemoryViews in Base","location":"base/#What's-wrong-with-SubArrays-of-Memory-as-memory-views?","category":"section","text":""},{"title":"MemoryViews in Base","page":"MemoryViews in Base","location":"base/","category":"page","text":"SubArray is generic over too much, and is therefore too hard to reason about, and to uphold its guarantees."},{"title":"MemoryViews in Base","page":"MemoryViews in Base","location":"base/","category":"page","text":"First, it's generic over the array type, meaning it may be backed by Memory or Vector, but also UnitRange or Base.LogRange (bitstypes, so not backed by memory), BitMatrix (memory-backed, but elements are stored packed), OffsetArrays, CodeUnits (memory-backed but immutable) and many more. What can you do with the underlying array, generally speaking? Take a pointer to it? No. Assume one-based indexing? No. Assume a stride of one? No. Assume mutability? No."},{"title":"MemoryViews in Base","page":"MemoryViews in Base","location":"base/","category":"page","text":"Second, it's generic over the index type. It may be UnitRange{Int}, of course, but also Base.OneTo{UInt16}, or StepRange{BigInteger}, CartesianIndices (which it itself generic over the indexes), Colon. Can you define the subset of these types which indicate dense indices? I can't."},{"title":"MemoryViews in Base","page":"MemoryViews in Base","location":"base/","category":"page","text":"Third, it's multidimensional. It may collect to a Vector or Matrix."},{"title":"MemoryViews in Base","page":"MemoryViews in Base","location":"base/","category":"page","text":"This is not a design flaw of SubArray - it's a perfectly fine design choice, which enables SubArray to be extremely flexible and broadly useful. Unfortunately, it also makes it nearly impossible to write robust, low-level code using SubArray, because it's almost impossible not to violate the assumptions of a subset of SubArrays many concrete types. Practically speaking, what happens is that methods taking SubArray fall back to only assuming what can be assumed about AbstractArray - which may be inefficient, and buggy (as the recurring bugs due to assumption of one-based indexing has taught us)."},{"title":"MemoryViews in Base","page":"MemoryViews in Base","location":"base/","category":"page","text":"In contrast, a MemoryView{T} is always represented by exactly a MemoryRef{T} and an Int as length. You know exactly what you get."},{"title":"Design decisions","page":"MemoryViews in Base","location":"base/#Design-decisions","category":"section","text":""},{"title":"Mutability","page":"MemoryViews in Base","location":"base/#Mutability","category":"section","text":""},{"title":"MemoryViews in Base","page":"MemoryViews in Base","location":"base/","category":"page","text":"Mutable and immutable memory views are statically distinguished, such that users can write methods that only take mutable memory views. This will statically prevent users from accidentally mutating e.g. strings."},{"title":"MemoryKind","page":"MemoryViews in Base","location":"base/#MemoryKind","category":"section","text":""},{"title":"MemoryViews in Base","page":"MemoryViews in Base","location":"base/","category":"page","text":"The MemoryKind trait is used because constructing a MemoryView only for dispatch purposes may not be able to be optimised away by the compiler for some types (currently, strings)."},{"title":"MemoryViews in Base","page":"MemoryViews in Base","location":"base/","category":"page","text":"MemoryKind could be replaced with a function that returned nothing, or the correct MemoryView type directly, but it's nicer to dispatch on ::MemoryKind than on ::Union{Nothing, Type{<:MemoryView}}."},{"title":"Limitations","page":"MemoryViews in Base","location":"base/#Limitations","category":"section","text":""},{"title":"MemoryViews in Base","page":"MemoryViews in Base","location":"base/","category":"page","text":"Many optimised fast methods for more established types like Vector are missing for MemoryView. These are added over time. Please make an issue or a PR as you encounter missing methods.\nCurrently, MemoryView does not make use of Core.GenericMemory's additional parameters, such as atomicity or address space. This may easily be added with a GenericMemoryView type, similar to Memory / GenericMemory.\nCurrently, Strings are not backed by Memory in Julia. Therefore, creating a MemoryView of a string requires heap-allocating a new Memory pointing to the existing memory of the string. This can be fixed if String is re-implemented to be backed by Memory, but I don't know enough details about the implementation of String to know if this is practical."},{"title":"Alternative proposal","page":"MemoryViews in Base","location":"base/#Alternative-proposal","category":"section","text":""},{"title":"MemoryViews in Base","page":"MemoryViews in Base","location":"base/","category":"page","text":"In examples/alternative.jl, there is an implementation where a MemoryView is just a pointer and a length. This makes it nearly identical to Random.UnsafeView, however, compared to UnsafeView, this proposal has:"},{"title":"MemoryViews in Base","page":"MemoryViews in Base","location":"base/","category":"page","text":"The MemoryKind trait, useful to control dispatch to functions that can treat arrays as being memory\nThe distinction between mutable and immutable memory views"},{"title":"MemoryViews in Base","page":"MemoryViews in Base","location":"base/","category":"page","text":"Overall, I like the alternative proposal less. Raw pointers are bad for safety and ergonomics, and they interact less nicely with the Julia runtime. Also, the existing GenericMemoryRef is essentially perfect for this purpose."},{"title":"Advantages","page":"MemoryViews in Base","location":"base/#Advantages","category":"section","text":""},{"title":"MemoryViews in Base","page":"MemoryViews in Base","location":"base/","category":"page","text":"Pointer-based memviews are cheaper to construct, and do not allocate for strings, unlike Memory. Perhaps in the future, strings too will be backed by Memory.\nPointer-based memory views allows interoperability with non-Julia memory like C owned structs easier."},{"title":"Disadvantages","page":"MemoryViews in Base","location":"base/#Disadvantages","category":"section","text":""},{"title":"MemoryViews in Base","page":"MemoryViews in Base","location":"base/","category":"page","text":"While some low-level methods using MemoryView will just forward to calling external libraries where using a pointer is fine, many will be written in pure Julia. There, it's less nice to have raw pointers.\nCode using pointer-based memviews must make sure to only have the views exist inside GC.@preserve blocks, which is annoying and will almost certainly be violated accidentally somewhere\nWe can't use advantages of the existing Memory infrastructure, e.g. having a GenericMemRef which supports atomic memory."},{"title":"MemoryViews.jl","page":"MemoryViews","location":"#MemoryViews.jl","category":"section","text":""},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"This package provide the MemoryView type, which is a lightweight and simple view into Memory. The MemoryView type is a useful low-level building block for code that operates on chunks of memory."},{"title":"Features:","page":"MemoryViews","location":"#Features:","category":"section","text":""},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"Simple and easy to reason about\nLow-overhead, efficient methods\nA safer alternative to pointers"},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"The MemoryView type has the following layout:"},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"struct MemoryView{T, M} <: DenseVector{T}\n    ref::MemoryRef{T},\n    len::Int\nend"},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"The M parameter is either Mutable or Immutable, which are unexported but public types defined in this package. MemoryViews also provide the following aliases for convenience:"},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"const MutableMemoryView{T} = MemoryView{T, Mutable}\nconst ImmutableMemoryView{T} = MemoryView{T, Immutable}"},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"Immutable memory views are immutable, in that they do not support setindex! or other mutating methods. The existence of an ImmutableMemoryView does not protect its underlying data from being mutated through another variable, or though explicitly unsafe functions, such as using raw pointers."},{"title":"Usage","page":"MemoryViews","location":"#Usage","category":"section","text":""},{"title":"Constructing memory views","page":"MemoryViews","location":"#Constructing-memory-views","category":"section","text":""},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"Construct memory views from x with MemoryView(x). MemoryViews should be constructable from any type that is stored as an array densely in memory. It can also be constructed from other non-array types that are represented by a chunk of memory (like a String). By default, constructors exists for the memory-backed types in Base:"},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"# Vectors\n@assert MemoryView([\"a\", \"b\", \"c\"]) isa MemoryView\n\n# Strings\n@assert MemoryView(\"abc\") isa MemoryView\n\n# Even complex nested memory-backed types\n@assert MemoryView(view(codeunits(view(\"abcd\", Base.OneTo(2))), :)) isa MemoryView"},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"For values x that are mutable such as Memorys and Arrays (and SubArrays of those), MemoryView(x) return MutableMemoryView:"},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"@assert MemoryView(Int32[1,2,3]) isa MutableMemoryView{Int32}\n@assert MemoryView(Memory{String}(undef, 3)) isa MutableMemoryView{String}"},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"For values that are immutable, MemoryView return ImmutableMemoryViews:"},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"@assert MemoryView(\"abc\") isa ImmutableMemoryView{UInt8}"},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"The constructor ImmutableMemoryView(x) will construct an immutable view no matter if the type returned by MemoryView(x) is mutable or not. This is because it's always possible to convert a mutable memory view to an immutable one:"},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"@assert MemoryView(UInt[]) isa MutableMemoryView{UInt}\n@assert ImmutableMemoryView(UInt[]) isa ImmutableMemoryView{UInt}"},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"Hence, when adding new constructors for new types, you should only add methods to MemoryView. This should return a mutable memview where possible."},{"title":"Indexing","page":"MemoryViews","location":"#Indexing","category":"section","text":""},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"MemoryView{T} is a subtype of AbstractVector{T}, and mostly behave like you would expect an abstract vector to behave w.r.t. indexing:"},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"mem = MemoryView([1,2,3,4,5,6,7,8])\n\nprintln(mem[2])\nprintln(mem[2:4])\nprintln(mem[end])\nprintln(mem[:])\n\n# output\n2\n[2, 3, 4]\n8\n[1, 2, 3, 4, 5, 6, 7, 8]"},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"One exception is slicing, which does not copy the underlying data, but simply returns a new view of the same data. To copy explicitly, use copy, which will create a new MemoryView that looks into a copy of the underlying data:"},{"title":"MemoryViews","page":"MemoryViews","location":"","category":"page","text":"mem1 = MemoryView([1,2,3])\nmem2 = mem1[1:3]\nmem3 = copy(mem1)\nmem1[1] = 3\nprintln(mem2[1])\nprintln(mem3[1])\n\n# output\n3\n1"}]
}
